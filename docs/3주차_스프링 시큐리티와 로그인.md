#### 세션(Session) 방식 로그인
서버가 사용자 정보를 서버 메모리 또는 Redis 같은 저장소에 Session ID와 함께 보관하고, 클라이언트는 쿠키로 이 Session ID를 보내면서 인증을 유지하는 방식.

#### Token 기반 로그인
사용자 정보를 바탕으로 서버가 암호화된 토큰(JWT 등)을 발급하고, 클라이언트는 이후 요청마다 이 토큰을 Authorization 헤더로 보내는 방식

#### JWT란 무엇인가요?

JSON Web Token
사용자 정보를 JSON 형태로 담고, 서버가 서명(Signature)을 추가해 만든 인증 토큰.

JWT = Header + Payload + Signature

#### JWT의 특징
##### 장점
- 서버가 상태(state)를 저장하지 않는 Stateless 인증
- 확장성 좋음
- 모바일에서도 잘 동작
##### 단점
- 쿠키/세션과 다르게 토큰의 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해짐
- Payload 자체는 암호화가 되지 않아 중요한 정보는 담을 수 없음
- 토큰을 탈취당한다면 대처가 어려움

#### 다양한 Token 종류
- Access Token: 짧은 수명, 요청 인증용
- Refresh Token: 긴 수명. AT 재발급 용도
- Opaque Token: 내용이 불투명한 랜덤 문자열. 서버 저장 필요
- JWT Token:	클라이언트가 유지하는 자체 포함 토큰.


#### Spring에서 JWT는 어떻게 생성할 수 있나요?

(추가해놓겠습니다)

.
.
.

#### Spring Security란 무엇인가요?
Spring 기반 애플리케이션의 **인증(Authentication)**과 **인가(Authorization)**를 처리하는 보안 프레임워크.
- 인증(Authentication): 사용자가 누구인지 확인하는 절차 (로그인)
- 인가(Authorization): 인증된 사용자가 어떤 자원을 사용할 수 있는지 권한 확인
  
#### Spring Security의 구조 (중요)
- Security Filter Chain: 수많은 보안 필터들이 체인 형태로 요청을 처리함.
- AuthenticationManager: 인증 수행 핵심 객체
- AuthenticationProvider: 실제 인증 로직을 수행 (UserDetailsService를 사용)
- UserDetailsService: DB에서 사용자 정보 조회
- UserDetails: 인증 완료 후 SecurityContext에 저장될 사용자 정보 객체
- SecurityContextHolder: 인증 정보 저장소 (ThreadLocal 기반)

#### Spring Security 작동 흐름

사용자가 로그인 요청 전송 -> UsernamePasswordAuthenticationFilter가 요청 가로챔 -> AuthenticationManager → AuthenticationProvider 호출
<br>-> UserDetailsService에서 사용자 조회 -> 비밀번호 검증 -> 인증 성공 → Authentication 객체 생성 -> SecurityContextHolder에 저장 -> 이후 요청마다 인증 정보 자동 확인
